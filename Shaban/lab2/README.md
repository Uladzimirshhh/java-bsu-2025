### README.md - Лабораторная работа по Java (Обработчик Транзакций)

#### 1. Базовый концепт и ООП

**Для чего существуют объектно-ориентированные языки программирования?**

ООП существует для:

1.  **Моделирования реального мира:** Представление сущностей (пользователь, счет) в виде объектов с их состоянием и поведением.
2.  **Управления сложностью:** Структурирование кода через инкапсуляцию, наследование и полиморфизм.
3.  **Повторного использования кода:** Создание абстракций (классы, интерфейсы) для повторного использования логики.

**Кто является объектом?**

Объект — это экземпляр класса, который имеет **состояние** (`currentBalance`), **поведение** (`deposit()`) и **идентичность** (`UUID`). В данном приложении ключевые объекты: `User`, `Account`, `Transaction`.

**Что такое UUID (Universally Unique Identifier)?**

UUID — это 128-битное число, используемое для уникальной идентификации информации. В распределенных системах гарантирует уникальность ID без централизованного координатора, что критически важно для всех сущностей (пользователей, счетов, транзакций).

#### 2. Транзакция

**Является ли такая предложенная архитектура нормальной? Предложите улучшения.<3**

*   **Архитектура:** Исходная архитектура является упрощенной. В реализованном решении `Transaction` ссылается **только на `UUID Account`**. Получение объекта счета происходит через абстрактный репозиторий.
*   **Улучшение (реализовано):** Снижена связанность (`Transaction` не знает о `User`). Разделение логики: изменение баланса вынесено в отдельные **Strategy** классы, что соответствует SOLID.

#### 3. Принципы SOLID (Привязка к Транзакциям)

| Принцип | Объяснение и Реализация в коде | Классы/Интерфейсы |
| :--- | :--- | :--- |
| **S**RP (Единственная Ответственность) | `DepositStrategy` отвечает только за логику пополнения. `TransactionProcessor` — только за управление асинхронным выполнением команд. | `DepositStrategy`, `TransactionProcessor` |
| **O**CP (Открытость/Закрытость) | Система **открыта для расширения**. Добавление нового типа операции (`CommissionStrategy`) реализуется созданием нового класса, **не изменяя** ядро обработчика (`TransactionProcessor`). | `TransactionStrategy` (интерфейс) |
| **L**SP (Принцип подстановки) | Любая конкретная стратегия транзакций (`DepositStrategy`, `TransferStrategy`) может подменять интерфейс `TransactionStrategy` без нарушения общей логики. | Все реализации `TransactionStrategy` |
| **I**SP (Разделение интерфейса) | Интерфейсы минимальны. `TransactionStatusListener` содержит только метод для уведомления об обновлении, необходимый для клиента (`BankSimulatorUI`). | `TransactionStatusListener` (интерфейс) |
| **D**IP (Инверсия зависимостей) | Высокоуровневый `TransactionProcessor` зависит от абстракций (`AccountRepository`), а не от конкретных реализаций хранилища (`MockAccountRepository`). | `TransactionProcessor`, `AccountRepository` |

#### 4. Паттерны Проектирования

| Паттерн | Применение в коде | Роль |
| :--- | :--- | :--- |
| **STRATEGY (Стратегия)** | `TransactionStrategy` и реализации (`DepositStrategy`, `TransferStrategy` и т.д.). | Инкапсуляция и взаимозаменяемость алгоритмов транзакций. |
| **FACTORY (Фабрика)** | `TransactionStrategyFactory`. | Создание конкретного экземпляра `TransactionStrategy` на основе типа операции. |
| **COMMAND (Команда)** | `TransactionCommand` (реализует `Runnable`). | Инкапсуляция запроса на выполнение транзакции, что позволяет отложить и асинхронно передать его в пул потоков. |
| **OBSERVER (Наблюдатель)** | `TransactionStatusListener` и `BankSimulatorUI`. | `TransactionProcessor` (Субъект) асинхронно уведомляет `BankSimulatorUI` (Наблюдатель) о статусе завершенной операции. |
| **SINGLETON (Одиночка)** | `TransactionProcessor`. | Гарантирует единственный централизованный экземпляр обработчика, управляющего пулом потоков и доступом к общим ресурсам. |
| **VISITOR (Посетитель)** | `TransactionVisitor` и `SummaryVisitor`. | Добавляет новую функциональность (отчет, анализ) к классу `Transaction` без изменения самого класса. |

#### 5. Асинхронность и Атомарность

**Что в языке программирования JAVA позволяет добиться атомарности и какие паттерны тут можно использовать?**

1.  **ExecutorService (Пул Потоков):** Реализован в `TransactionProcessor` для асинхронного выполнения команд. Это обеспечивает высокую пропускную способность, не блокируя UI-поток.
2.  **Явные Блокировки (`ReentrantLock`):** Используются в классе `Account` (поле `accountOperationLock`). Это гарантирует, что одновременные операции записи в одно поле (`currentBalance`) выполняются последовательно, обеспечивая **атомарность** изменения баланса.
3.  **Предотвращение Deadlock (Взаимная блокировка):** В `TransferStrategy` реализован принцип **Ordered Locking**: счета блокируются в определенном порядке (по возрастанию `UUID`), что исключает возможность взаимных блокировок при одновременных встречных переводах.

**UI / Swing:**

Реализован с использованием `GridBagLayout` и приемов Swing (например, установка минимального размера окна, управление `ItemListener` для предотвращения рекурсии), обеспечивая стабильность и интерактивность UI в многопоточной среде.