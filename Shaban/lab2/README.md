### README.md - Лабораторная работа по Java (Обработчик Транзакций)

#### 1. Базовый концепт и ООП

**Для чего существуют объектно-ориентированные языки программирования?**

ООП существует для:

1.  **Моделирования реального мира:** Представление реальных сущностей (пользователь, счет, транзакция) в виде объектов с их состоянием (поля) и поведением (методы).
2.  **Управления сложностью:** Структурирование кода через инкапсуляцию, наследование и полиморфизм для создания легко поддерживаемых и масштабируемых систем.
3.  **Повторного использования кода:** Создание абстракций (классы, интерфейсы) для повторного использования логики.

**Кто является объектом?**

Объект — это экземпляр класса, который имеет **состояние** (`currentBalance`), **поведение** (`deposit()`, `withdraw()`), и **идентичность** (`UUID`). В нашем приложении объекты: `User`, `Account`, `Transaction`, `TransactionProcessor`.

#### 2. Транзакция

**Что такое UUID (Universally Unique Identifier)?**

UUID — это 128-битное число, используемое для уникальной идентификации информации в распределенных компьютерных системах. Гарантирует уникальность ID без централизованного координирующего органа, что критически важно для всех сущностей в распределенной банковской системе (отсюда — использование его для `Transaction`, `Account` и `User`).

**Является ли такая предложенная архитектура нормальной? Предложите улучшения.<3**

*   **Архитектура:** Предложенная архитектура (`Transaction` содержит `accountIdentifier` — идентификатор счета из списка счетов пользователя) является **упрощенной и достаточной для демонстрации концепции, но не оптимальной для реальной системы**.

*   **Улучшения (Реализованы в коде):**
    1.  **Снижение Связанности (Coupling):** Исключить прямую связь между `User` и `Transaction`. В нашем решении `Transaction` ссылается **только на `UUID Account`**. Получение счета происходит через абстрактный `AccountRepository`. Это усиливает инкапсуляцию и делает систему более модульной.
    2.  **Разделение логики:** Используются **Стратегии** (`DepositStrategy`, `WithdrawalStrategy`) для отделения логики изменения баланса от класса `Account` и класса `Transaction`.

#### 3. Принципы SOLID (Привязка к Транзакциям)

| Принцип | Объяснение и Реализация в коде | Классы/Интерфейсы |
| :--- | :--- | :--- |
| **S**RP (Единственная Ответственность) | Каждый класс отвечает только за одну часть бизнес-логики. `DepositStrategy` отвечает *только* за логику пополнения. `TransactionProcessor` отвечает *только* за управление потоками и оркестрацию. | `DepositStrategy`, `TransactionProcessor` |
| **O**CP (Открытость/Закрытость) | Система **открыта для расширения**, но **закрыта для модификации**. Для добавления нового типа транзакции (например, `CommissionStrategy`) достаточно создать новый класс, реализующий `TransactionStrategy`, без изменения `TransactionStrategyFactory` или `TransactionProcessor`. | `TransactionStrategy` (интерфейс) |
| **L**SP (Принцип подстановки) | Любая конкретная реализация стратегии (`DepositStrategy`, `FreezeStrategy`) может быть использована как `TransactionStrategy` без нарушения работы. | Все реализации `TransactionStrategy` |
| **I**SP (Разделение интерфейса) | Интерфейсы должны быть минимально необходимыми для клиента. `TransactionStatusListener` содержит только один метод (`notifyTransactionUpdate`), исключая ненужные методы для UI. | `TransactionStatusListener` (интерфейс) |
| **D**IP (Инверсия зависимостей) | Высокоуровневые модули (`TransactionProcessor`) не зависят от низкоуровневых модулей (реализации хранилища). Они зависят от абстракций (`AccountRepository`, `TransactionStrategyFactory`). | `TransactionProcessor`, `AccountRepository` |

#### 4. Паттерны Проектирования (P.S. Все реализованы в коде)

| Паттерн | Применение в коде | Роль |
| :--- | :--- | :--- |
| **STRATEGY (Стратегия)** | `TransactionStrategy` (интерфейс) и `DepositStrategy`, `WithdrawalStrategy`, `TransferStrategy`. | Инкапсуляция алгоритмов обработки транзакций в отдельные, взаимозаменяемые классы. |
| **FACTORY (Фабрика)** | `TransactionStrategyFactory`. | Создание конкретного экземпляра `TransactionStrategy` на основе перечисления `TransactionActionType`, скрывая логику инстанцирования. |
| **COMMAND (Команда)** | `TransactionCommand` (реализует `Runnable`). | Инкапсулирует вызов метода (`executeTransaction`) в объекте, что позволяет отложить или поставить в очередь выполнение операции в асинхронном пуле. |
| **OBSERVER (Наблюдатель)** | `TransactionStatusListener` и `BankSimulatorUI`. | `TransactionProcessor` (Субъект) асинхронно уведомляет `BankSimulatorUI` (Наблюдателя) о завершении транзакции. |
| **SINGLETON (Одиночка)** | `TransactionProcessor`. | Гарантирует, что в системе существует только один централизованный обработчик транзакций, контролирующий пул потоков и доступ к репозиториям. |
| **VISITOR (Посетитель)** | `TransactionVisitor` и `SummaryVisitor`. | Добавляет новую функциональность (отчет, сбор статистики) к объекту `Transaction` без изменения самого класса `Transaction`. |

#### 5. Асинхронность и Атомарность

**Что в языке программирования JAVA позволяет добиться атомарности и какие паттерны тут можно использовать?**

Для обеспечения атомарности и потокобезопасности в Java (при обработке миллионов запросов) используется следующее:

1.  **ExecutorService (Пул Потоков):** Реализован в `TransactionProcessor`. Он управляет пулом рабочих потоков и эффективно распределяет выполнение `TransactionCommand` (паттерн Command), обеспечивая асинхронность без затрат на постоянное создание новых потоков.
2.  **Явные Блокировки (`ReentrantLock`):** Используется внутри класса `Account` (поле `accountOperationLock`) и непосредственно в стратегиях. Блокировка гарантирует, что одновременное чтение и запись баланса счета выполняется последовательно, обеспечивая **атомарность** для каждой транзакции.
3.  **Предотвращение Deadlock (Взаимная блокировка):** В `TransferStrategy` реализован принцип **Ordered Locking (Упорядоченная Блокировка)**: локи счетов всегда захватываются в порядке возрастания их `UUID` для предотвращения Deadlock при встречных переводах.

**Дополнительно:**

*   **UI/Swing:** Реализован с использованием `Swing` и `GridBagLayout` с `SwingUtilities.invokeLater()` для потокобезопасного обновления интерфейса, следуя правилам Java Event Dispatch Thread (EDT).
*   **Хранение данных:** В качестве заглушки (P.S. 2) использован `MockAccountRepository` (и JDBC-Ready интерфейс), реализующий `ConcurrentHashMap` для потокобезопасного доступа к данным.